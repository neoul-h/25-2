""""
[파일 구성]
- Part 1: SNS 시간 분석
  - (이름, 시간, 이름, 시간, ...) 형태의 튜플을 dict로 변환 후 총합/평균/최대값 계산 및 출력
- Part 2: 럭키박스 이벤트
  - 문제에서 주어진 while 루프를 그대로 유지
  - addBox(), winner() 함수만 구현하여 동작하게 함
"""

# ▶ 맨 위에 학번/이름 출력
print("********************************")
print("학번: 202104008, 이름: 김진우")
print("********************************")

# ---------------------------------------------------------------------
# [Part 1] SNS 시간 분석
#  - 아래 snsTime 튜플은 (이름, 시간, 이름, 시간, ...) 구조다.
#  - 다루기 쉽게 dict로 변환한 뒤, 총합/평균/최대 사용 SNS를 계산한다.
# ---------------------------------------------------------------------

# snsTime: 플랫폼 이름과 사용 시간을 번갈아 담은 튜플(수정 금지 가정)
snsTime = (
    "Instagram", 10,
    "TikTok", 12,
    "Facebook", 8,
    "Twitter", 7,
    "Snapchat", 9,
    "YouTube", 15,
    "LinkedIn", 4
)

def to_dict_from_pair_tuple(pairs):
    """
    (키,값,키,값,...) 형태의 튜플을 딕셔너리로 변환한다.
    - pairs: 짝수 길이의 튜플. (0,1) (2,3) (4,5) ...가 (키,값) 쌍이 된다.
    - 반환값: {키:값, ...} 형태의 dict
    """
    d = {}             # 결과를 담을 빈 dict
    i = 0              # 인덱스는 0부터 시작
    while i < len(pairs):          # 튜플 길이만큼 반복
        key = pairs[i]             # 짝 중 앞의 원소가 키(문자열: SNS 이름)
        val = pairs[i + 1]         # 짝 중 뒤의 원소가 값(정수: 사용 시간)
        d[key] = val               # dict에 할당(동일 키가 오면 최신값으로 덮어씀)
        i = i + 2                  # 다음 쌍으로 이동(2칸 이동)
    return d                        # 완성된 dict 반환

def total_time(d):
    """
    딕셔너리 d의 모든 값을 더해 총 사용 시간을 반환한다.
    - d의 키는 SNS 이름, 값은 사용 시간(분)이라고 가정.
    """
    s = 0                           # 누적 합계를 저장할 변수
    for k in d:                     # dict를 순회하면 기본적으로 키가 순회된다
        s = s + d[k]                # 각 키의 값을 더해 누적
    return s                        # 총합 반환

def average_time(d):
    """
    딕셔너리 d의 평균 사용 시간을 반환한다.
    - 항목 수가 0인 경우 0을 반환(0으로 나누기 방지).
    """
    count = 0                       # 항목 수를 셀 변수
    for _ in d:                     # 키의 개수를 세기 위해 단순 순회
        count = count + 1
    if count == 0:                  # 빈 딕셔너리인 경우
        return 0
    return total_time(d) * 1.0 / count   # 실수 나눗셈으로 평균 반환

def most_used(d):
    """
    가장 사용 시간이 큰 (플랫폼, 시간) 튜플을 반환한다.
    - 첫 항목을 기준으로 초기화한 뒤, 큰 값을 만나면 갱신한다.
    """
    first = True                    # 첫 반복 여부를 표시(초기 비교값 설정용)
    best_k = None                   # 최대 시간을 가진 플랫폼 이름
    best_v = 0                      # 그 플랫폼의 사용 시간
    for k in d:                     # 모든 키를 순회
        if first or d[k] > best_v:  # 첫 회차이거나 현재 값이 더 크면 갱신
            best_k = k
            best_v = d[k]
            first = False
    return best_k, best_v           # (플랫폼, 시간) 형태로 결과 반환

def print_sns_report(d):
    """
    SNS 사용 요약 리포트를 보기 좋은 형식으로 출력한다.
    - 각 SNS 이름과 시간, 총합/평균/최대 사용을 출력한다.
    """
    print("\n[SNS 사용 시간 리포트]")      # 리포트 제목 출력
    for k in d:                              # 개별 항목을 한 줄씩 출력
        print("- {0}: {1}분".format(k, d[k]))
    tot = total_time(d)                      # 총합 계산
    avg = average_time(d)                    # 평균 계산
    mk, mv = most_used(d)                    # 최대 사용 SNS와 시간
    print("\n총합: {0}분".format(tot))       # 총합 출력
    print("평균: {0:.2f}분".format(avg))     # 평균(소수 2자리) 출력
    print("최대 사용: {0} ({1}분)".format(mk, mv))  # 최대 사용 출력

# --- Part 1 실행부 ---
d = to_dict_from_pair_tuple(snsTime)   # 튜플을 dict로 변환
print_sns_report(d)                    # 변환한 dict로 리포트 출력

# ---------------------------------------------------------------------
# [Part 2] 럭키박스 이벤트
#  - 문제에서 주어진 while 루프를 그대로 유지한다.
#  - addBox(): 사용자 입력을 받아 후보 리스트에 조건부로 추가(중복/빈값 제외)
#  - winner(): 후보 중 1명을 무작위로 선택(후보가 없으면 안내 문자열)
#  - 'end'를 입력하면 name 전역변수가 "end"가 되어 루프 종료.
# ---------------------------------------------------------------------

import random  # 표준 라이브러리(수업 범위)에서 무작위 선택에 사용하는 모듈

# luckyBox: 기본 당첨 후보가 담긴 리스트(문제에서 주어졌다고 가정)
luckyBox = [
    "아이유", "뷔", "정국", "손예진", "박보검",
    "임영웅", "한지민", "유재석", "이효리", "차은우",
    "송중기", "장원영", "지수", "이도현", "김태리"
]

# name: 문제에서 while 루프의 종료 조건으로 사용하는 전역 변수
name = ""  # 빈 문자열로 시작 → 첫 반복에서 입력을 받아 값이 바뀜

def addBox(box):
    """
    사용자에게 이름을 입력 받아 후보 리스트(box)에 추가한다.
    - 입력이 'end'이면 전역 name에 'end'를 기록하여 while 루프가 종료되도록 함.
    - 입력이 빈 문자열이면 무시(추가하지 않음).
    - 이미 존재하는 이름이면 중복 추가하지 않음.
    """
    global name                                 # while 종료를 위해 전역변수 name에 접근
    prompt = "추가할 이름을 입력하세요 (end 입력 시 종료): "  # 사용자 안내 문구
    entered = input(prompt).strip()             # 좌우 공백 제거하여 깔끔하게 처리
    name = entered                              # 전역 name 갱신 → while 조건 검사에 사용
    if name != "end":                           # 'end'가 아니면 실제 추가 시도
        if entered != "":                       # 빈 입력은 무시
            # box에 동일한 이름이 없을 때만 추가 → 중복 방지
            if entered not in box:
                box.append(entered)             # 리스트 끝에 새 후보 추가
            # else: 이미 있으므로 아무 작업 안 함
        # else: 빈 문자열이므로 아무 작업 안 함

def winner(box):
    """
    후보 리스트(box)에서 무작위로 한 명을 선택해 문자열로 반환한다.
    - 후보가 0명인 경우 '후보 없음'을 반환하여 예외 상황을 알림.
    """
    if len(box) == 0:                   # 리스트가 비어 있으면
        return "후보 없음"              # 안내 문자열 반환
    return random.choice(box)           # 무작위로 1명 선택해 반환

# --- Part 2 실행부 ---
print("\n[럭키박스 이벤트 시작] (end 입력 시 종료)")  # 이벤트 시작 안내

# === 문제에서 주어진 루프(그대로 유지해야 함) ===
while name != "end":                     # 전역 name이 'end'가 될 때까지 반복
    addBox(luckyBox)                     # 사용자 입력을 받아 후보에 추가(또는 종료 신호)
    # 매 반복마다 즉시 무작위 당첨자를 출력(문제 출력 형식에 맞춤)
    print("*축*당첨자:{0}".format(winner(luckyBox)))
# ===============================================

# 종료 후 최종 현황을 정리해서 보여주기(선택 사항: 결과 확인용 출력)
print("\n최종 후보 수:", len(luckyBox))  # 남아 있는(또는 추가된) 후보의 총 개수 출력

# 문자열 join은 수업 범위일 수 있으나, 보수적으로 직접 연결하여 제출 안정성 확보
s = ""                                   # 후보 목록을 이어붙일 문자열 버퍼
idx = 0                                  # 쉼표 구분을 위해 첫 항목 여부를 표시
for item in luckyBox:                    # 후보 리스트를 순서대로 순회
    if idx > 0:                          # 첫 항목이 아닌 경우에만 앞에 ", " 추가
        s = s + ", "
    s = s + item                         # 현재 후보 이름을 결과 문자열에 덧붙임
    idx = idx + 1                        # 인덱스(항목 수) 증가
print("후보 목록: " + s)                  # 쉼표로 구분된 후보 전체 이름을 한 줄로 출력
