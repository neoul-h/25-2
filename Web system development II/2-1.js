// 2-1.js
// 목적: setImmediate 등록 순서와 마이크로태스크(then) 타이밍에 따라
//       로그가 언제 실행되는지 확인하기

let v = 1; // 시작값

// (A) check 단계에서 실행될 콜백 1: v += 5
//     → 가장 먼저 등록됨
let id = setImmediate(() => {
  // 실행 시점에 v: 1(초기) → +5 후 6
  v += 5;
});

// (B) Promise executor는 "동기"로 실행된다.
//     내부에서 setImmediate(+2)를 등록하고, 즉시 resolve()를 호출한다.
new Promise(resolve => {
  // (B1) check 단계에서 실행될 콜백 2: v += 2
  setImmediate(() => {
    // 앞선 (A)가 먼저 실행되어 v가 6이 된 후 실행되므로 → 6 + 2 = 8
    v += 2;
  });

  // (B2) 그냥 즉시 해결. then 핸들러는 "마이크로태스크"로 대기한다.
  resolve();
})
// (C) then 핸들러는 "현재 동기 코드가 끝난 직후" 마이크로태스크로 실행되어
//     그 안에서 또 다른 setImmediate(×2)를 등록한다.
.then(() => {
  // (C1) check 단계에서 실행될 콜백 4: v *= 2
  setImmediate(() => {
    // 이 콜백은 "로그 setImmediate"보다 나중에 등록되므로, 로그 뒤에 실행됨!
    // 로그가 8을 찍고 난 다음에 실행되어 8 * 2 = 16 (출력되지 않음)
    v *= 2;
  });
});

// (D) check 단계에서 실행될 콜백 3: 현재 v를 출력
//     ⚠️ 이 줄은 "동기"로 바로 실행되며, 위의 then 핸들러(마이크로태스크)가
//     실행되기 전에 이미 등록된다. → 등록 순서: (A)→(B1)→(D)→(C1)
setImmediate(() => {
  // (A)→(B1) 실행 후 v는 8, 따라서 콘솔에는 8이 찍힌다.
  console.log(v);
});

/*
[핵심 타임라인: 같은 루프의 check 단계 FIFO]
1) (A) v += 5  : 1 → 6
2) (B1) v += 2 : 6 → 8
3) (D)  log(8) : 8 출력
4) (C1) v *= 2 : 8 → 16  (로그 이후 실행되어 화면에는 안 보임)

[예상 출력]
8
*/
